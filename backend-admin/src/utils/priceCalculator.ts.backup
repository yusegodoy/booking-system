import { IVehicleType } from '../models/VehicleType';
import Area from '../models/Area';

interface Location {
  lat: number;
  lng: number;
  address?: string;
  zipcode?: string;
  city?: string;
}

interface PriceCalculationResult {
  basePrice: number;
  distancePrice: number;
  totalPrice: number;
  distance: number;
  areaDiscount?: number;
  areaName?: string;
  surgeMultiplier?: number;
  surgeName?: string;
  pricingMethod: 'fixed' | 'distance';
}

// Function to calculate distance between two points using Haversine formula
function calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {
  const R = 3959; // Earth's radius in miles
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLng = (lng2 - lng1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLng/2) * Math.sin(dLng/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// Function to check if a location is within an area
async function isLocationInArea(location: Location, area: any): Promise<boolean> {
  switch (area.type) {
    case 'city':
      return location.city?.toLowerCase() === area.value.toLowerCase();
    
    case 'zipcode':
      return location.zipcode === area.value;
    
    case 'polygon':
      if (!area.polygon || area.polygon.length < 3) return false;
      return isPointInPolygon(location.lat, location.lng, area.polygon);
    
    default:
      return false;
  }
}

// Function to check if a point is inside a polygon (ray casting algorithm)
function isPointInPolygon(lat: number, lng: number, polygon: Array<{lat: number, lng: number}>): boolean {
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].lng;
    const yi = polygon[i].lat;
    const xj = polygon[j].lng;
    const yj = polygon[j].lat;
    
    if (((yi > lat) !== (yj > lat)) && (lng < (xj - xi) * (lat - yi) / (yj - yi) + xi)) {
      inside = !inside;
    }
  }
  return inside;
}

// Main function to calculate prices
// RULE: When pickup or dropoff points are in multiple areas, the HIGHEST PRICE is used
export async function calculatePrice(
  vehicleType: IVehicleType,
  pickup: Location,
  dropoff: Location,
  options: {
    stops?: Location[];
    childSeats?: number;
    roundTrip?: boolean;
    pickupDateTime?: Date; // For surge pricing
  } = {}
): Promise<PriceCalculationResult> {
  const { stops = [], childSeats = 0, roundTrip = false, pickupDateTime = new Date() } = options;
  
  // Calculate total distance
  let totalDistance = calculateDistance(pickup.lat, pickup.lng, dropoff.lat, dropoff.lng);
  
  // Add distance for additional stops
  let currentLocation = pickup;
  for (const stop of stops) {
    totalDistance += calculateDistance(currentLocation.lat, currentLocation.lng, stop.lat, stop.lng);
    currentLocation = stop;
  }
  if (stops.length > 0) {
    totalDistance += calculateDistance(currentLocation.lat, currentLocation.lng, dropoff.lat, dropoff.lng);
  }

  // Check if there are fixed prices by area
  if (vehicleType.areaPrices && vehicleType.areaPrices.length > 0) {
    // Find areas that match pickup or dropoff
    const matchingAreas = [];
    
    for (const areaPrice of vehicleType.areaPrices) {
      const area = await Area.findById(areaPrice.area);
      if (!area) continue;
      
      const pickupInArea = await isLocationInArea(pickup, area);
      const dropoffInArea = await isLocationInArea(dropoff, area);
      
      if (pickupInArea || dropoffInArea) {
        matchingAreas.push({
          area,
          fixedPrice: areaPrice.fixedPrice,
          pickupInArea,
          dropoffInArea
        });
      }
    }
    
    // If there are matching areas, use the HIGHEST PRICE (new rule)
    if (matchingAreas.length > 0) {
      // Sort by price in descending order (highest first)
      matchingAreas.sort((a, b) => b.fixedPrice - a.fixedPrice);
      const highestPriceArea = matchingAreas[0];
      
      let totalPrice = highestPriceArea.fixedPrice;
      
      // Add additional charges
      if (stops.length > 0) {
        totalPrice += vehicleType.stopCharge * stops.length;
      }
      
      if (childSeats > 0) {
        totalPrice += vehicleType.childSeatCharge * childSeats;
      }
      
      if (roundTrip) {
        totalPrice = totalPrice * (1 - vehicleType.roundTripDiscount / 100);
      }
      
      // Create area name showing all matching areas
      const matchingAreaNames = matchingAreas.map(ma => ma.area.name).join(', ');
      
      return {
        basePrice: highestPriceArea.fixedPrice,
        distancePrice: 0,
        totalPrice,
        distance: totalDistance,
        areaName: matchingAreas.length > 1 ? 
          `Multiple areas: ${matchingAreaNames} (using highest: $${highestPriceArea.fixedPrice})` : 
          highestPriceArea.area.name,
        pricingMethod: 'fixed'
      };
    }
  }

  // If no fixed prices by area, use distance-based calculation with configurable tiers
  let basePrice = vehicleType.basePrice;
  let distancePrice = 0;

  // Calculate distance price using configurable tiers
  if (vehicleType.distanceTiers && vehicleType.distanceTiers.length > 0) {
    // Sort tiers by fromMiles to ensure proper order
    const sortedTiers = [...vehicleType.distanceTiers].sort((a, b) => a.fromMiles - b.fromMiles);
    
    for (const tier of sortedTiers) {
      if (totalDistance >= tier.fromMiles && (tier.toMiles === 0 || totalDistance <= tier.toMiles)) {
        const tierDistance = Math.min(totalDistance, tier.toMiles || totalDistance) - tier.fromMiles;
        distancePrice += tierDistance * tier.pricePerMile;
        break; // Use the first matching tier
      }
    }
  } else {
    // Fallback to old calculation if no tiers are configured
    if (totalDistance <= 12) {
      distancePrice = totalDistance * 3.5;
    } else if (totalDistance <= 20) {
      distancePrice = 12 * 3.5 + (totalDistance - 12) * 2;
    } else {
      distancePrice = 12 * 3.5 + 8 * 2 + (totalDistance - 20) * 2;
    }
  }

  let totalPrice = basePrice + distancePrice;

  // Apply surge pricing if applicable
  let surgeMultiplier = 1;
  let surgeName = '';
  
  if (vehicleType.surgePricing && vehicleType.surgePricing.length > 0) {
    const applicableSurges = [];
    
    for (const surge of vehicleType.surgePricing) {
      if (!surge.isActive) continue;
      
      let isApplicable = true;
      
      // Check days of week
      if (surge.daysOfWeek && surge.daysOfWeek.length > 0) {
        const dayOfWeek = pickupDateTime.getDay();
        if (!surge.daysOfWeek.includes(dayOfWeek)) {
          isApplicable = false;
        }
      }
      
      // Check time range
      if (surge.startTime && surge.endTime) {
        const currentTime = pickupDateTime.toTimeString().substring(0, 5); // HH:MM
        if (currentTime < surge.startTime || currentTime > surge.endTime) {
          isApplicable = false;
        }
      }
      
      // Check date range
      if (surge.startDate && surge.endDate) {
        const currentDate = pickupDateTime.toISOString().split('T')[0];
        const startDate = new Date(surge.startDate).toISOString().split('T')[0];
        const endDate = new Date(surge.endDate).toISOString().split('T')[0];
        if (currentDate < startDate || currentDate > endDate) {
          isApplicable = false;
        }
      }
      
      // Check specific dates
      if (surge.specificDates && surge.specificDates.length > 0) {
        const currentDate = pickupDateTime.toISOString().split('T')[0];
        const hasSpecificDate = surge.specificDates.some(date => 
          new Date(date).toISOString().split('T')[0] === currentDate
        );
        if (!hasSpecificDate) {
          isApplicable = false;
        }
      }
      
      if (isApplicable) {
        applicableSurges.push(surge);
      }
    }
    
    // Use the surge with highest priority
    if (applicableSurges.length > 0) {
      applicableSurges.sort((a, b) => b.priority - a.priority);
      const highestSurge = applicableSurges[0];
      surgeMultiplier = highestSurge.multiplier;
      surgeName = highestSurge.name;
    }
  }

  // Apply surge multiplier
  totalPrice = totalPrice * surgeMultiplier;

  // Add additional charges
  if (stops.length > 0) {
    totalPrice += vehicleType.stopCharge * stops.length;
  }

  if (childSeats > 0) {
    totalPrice += vehicleType.childSeatCharge * childSeats;
  }

  if (roundTrip) {
    totalPrice = totalPrice * (1 - vehicleType.roundTripDiscount / 100);
  }

  return {
    basePrice,
    distancePrice,
    totalPrice,
    distance: totalDistance,
    surgeMultiplier: surgeMultiplier > 1 ? surgeMultiplier : undefined,
    surgeName: surgeName || undefined,
    pricingMethod: 'distance'
  };
}

// Function to get all available areas
export async function getAvailableAreas(): Promise<any[]> {
  return await Area.find().sort({ name: 1 });
}

// Function to check if a location is in any area with fixed price
export async function checkLocationInPricedAreas(
  location: Location,
  vehicleType: IVehicleType
): Promise<{ area: any; fixedPrice: number } | null> {
  if (!vehicleType.areaPrices || vehicleType.areaPrices.length === 0) {
    return null;
  }

  const matchingAreas = [];

  for (const areaPrice of vehicleType.areaPrices) {
    const area = await Area.findById(areaPrice.area);
    if (!area) continue;

    const isInArea = await isLocationInArea(location, area);
    if (isInArea) {
      matchingAreas.push({ area, fixedPrice: areaPrice.fixedPrice });
    }
  }

  // Return the area with the highest price (new rule)
  if (matchingAreas.length > 0) {
    matchingAreas.sort((a, b) => b.fixedPrice - a.fixedPrice);
    return matchingAreas[0];
  }

  return null;
} 